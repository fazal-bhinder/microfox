{
  "url": "https://google.github.io/adk-docs/tools/authentication/",
  "content": "Skip to content\nAgent Development Kit\nAuthentication\nType to start searching\nAgent Development Kit\n adk-python\nHome\nGet Started\nGet Started\nInstallation\nQuickstart\nQuickstart (streaming)\nTesting\nSample agents\nAbout ADK\nTutorials\nTutorials\nAgent Team\nAgents\nAgents\nLLM agents\nWorkflow agents\nWorkflow agents\nSequential agents\nLoop agents\nParallel agents\nCustom agents\nMulti-agent systems\nModels\nTools\nTools\nFunction tools\nBuilt-in tools\nThird party tools\nGoogle Cloud tools\nMCP tools\nOpenAPI tools\nAuthentication\nTable of contents\nCore Concepts\nSupported Initial Credential Types\nConfiguring Authentication on Tools\nJourney 1: Building Agentic Applications with Authenticated Tools\n1. Configuring Tools with Authentication\n2. Handling the Interactive OAuth/OIDC Flow (Client-Side)\nJourney 2: Building Custom Tools (FunctionTool) Requiring Authentication\nPrerequisites\nAuthentication Logic within the Tool Function\nRunning Agents\nRunning Agents\nRuntime Config\nDeploy\nDeploy\nAgent Engine\nCloud Run\nGKE\nSessions & Memory\nSessions & Memory\nSession\nState\nMemory\nCallbacks\nCallbacks\nTypes of callbacks\nCallback patterns\nArtifacts\nArtifacts\nEvents\nEvents\nContext\nContext\nEvaluate\nEvaluate\nMCP\nMCP\nStreaming\nStreaming\nSafety and Security\nAgent2Agent (A2A) Protocol\nCommunity Resources\nContributing Guide\nAPI Reference\nAuthenticating with Tools¶\nCore Concepts¶\n\nMany tools need to access protected resources (like user data in Google Calendar, Salesforce records, etc.) and require authentication. ADK provides a system to handle various authentication methods securely.\n\nThe key components involved are:\n\nAuthScheme: Defines how an API expects authentication credentials (e.g., as an API Key in a header, an OAuth 2.0 Bearer token). ADK supports the same types of authentication schemes as OpenAPI 3.0. To know more about what each type of credential is, refer to OpenAPI doc: Authentication. ADK uses specific classes like APIKey, HTTPBearer, OAuth2, OpenIdConnectWithConfig.\nAuthCredential: Holds the initial information needed to start the authentication process (e.g., your application's OAuth Client ID/Secret, an API key value). It includes an auth_type (like API_KEY, OAUTH2, SERVICE_ACCOUNT) specifying the credential type.\n\nThe general flow involves providing these details when configuring a tool. ADK then attempts to automatically exchange the initial credential for a usable one (like an access token) before the tool makes an API call. For flows requiring user interaction (like OAuth consent), a specific interactive process involving the Agent Client application is triggered.\n\nSupported Initial Credential Types¶\nAPI_KEY: For simple key/value authentication. Usually requires no exchange.\nHTTP: Can represent Basic Auth (not recommended/supported for exchange) or already obtained Bearer tokens. If it's a Bearer token, no exchange is needed.\nOAUTH2: For standard OAuth 2.0 flows. Requires configuration (client ID, secret, scopes) and often triggers the interactive flow for user consent.\nOPEN_ID_CONNECT: For authentication based on OpenID Connect. Similar to OAuth2, often requires configuration and user interaction.\nSERVICE_ACCOUNT: For Google Cloud Service Account credentials (JSON key or Application Default Credentials). Typically exchanged for a Bearer token.\nConfiguring Authentication on Tools¶\n\nYou set up authentication when defining your tool:\n\nRestApiTool / OpenAPIToolset: Pass auth_scheme and auth_credential during initialization\n\nGoogleApiToolSet Tools: ADK has built-in 1st party tools like Google Calendar, BigQuery etc,. Use the toolset's specific method.\n\nAPIHubToolset / ApplicationIntegrationToolset: Pass auth_scheme and auth_credentialduring initialization, if the API managed in API Hub / provided by Application Integration requires authentication.\n\nWARNING\n\nStoring sensitive credentials like access tokens and especially refresh tokens directly in the session state might pose security risks depending on your session storage backend (SessionService) and overall application security posture.\n\nInMemorySessionService: Suitable for testing and development, but data is lost when the process ends. Less risk as it's transient.\nDatabase/Persistent Storage: Strongly consider encrypting the token data before storing it in the database using a robust encryption library (like cryptography) and managing encryption keys securely (e.g., using a key management service).\nSecure Secret Stores: For production environments, storing sensitive credentials in a dedicated secret manager (like Google Cloud Secret Manager or HashiCorp Vault) is the most recommended approach. Your tool could potentially store only short-lived access tokens or secure references (not the refresh token itself) in the session state, fetching the necessary secrets from the secure store when needed.\nJourney 1: Building Agentic Applications with Authenticated Tools¶\n\nThis section focuses on using pre-existing tools (like those from RestApiTool/ OpenAPIToolset, APIHubToolset, GoogleApiToolSet) that require authentication within your agentic application. Your main responsibility is configuring the tools and handling the client-side part of interactive authentication flows (if required by the tool).\n\n1. Configuring Tools with Authentication¶\n\nWhen adding an authenticated tool to your agent, you need to provide its required AuthScheme and your application's initial AuthCredential.\n\nA. Using OpenAPI-based Toolsets (OpenAPIToolset, APIHubToolset, etc.)\n\nPass the scheme and credential during toolset initialization. The toolset applies them to all generated tools. Here are few ways to create tools with authentication in ADK.\n\nAPI Key\nOAuth2\nService Account\nOpenID connect\n\nCreate a tool requiring an API Key.\n\nfrom google.adk.tools.openapi_tool.auth.auth_helpers import token_to_scheme_credential\n\nfrom google.adk.tools.apihub_tool.apihub_toolset import APIHubToolset\u000b\n\nauth_scheme, auth_credential = token_to_scheme_credential(\n\n   \"apikey\", \"query\", \"apikey\", YOUR_API_KEY_STRING\n\n)\n\nsample_api_toolset = APIHubToolset(\n\n   name=\"sample-api-requiring-api-key\",\n\n   description=\"A tool using an API protected by API Key\",\n\n   apihub_resource_name=\"...\",\n\n   auth_scheme=auth_scheme,\n\n   auth_credential=auth_credential,\n\n)\n\n\nB. Using Google API Toolsets (e.g., calendar_tool_set)\n\nThese toolsets often have dedicated configuration methods.\n\nTip: For how to create a Google OAuth Client ID & Secret, see this guide: Get your Google API Client ID\n\n# Example: Configuring Google Calendar Tools\n\nfrom google.adk.tools.google_api_tool import calendar_tool_set\n\n\n\nclient_id = \"YOUR_GOOGLE_OAUTH_CLIENT_ID.apps.googleusercontent.com\"\n\nclient_secret = \"YOUR_GOOGLE_OAUTH_CLIENT_SECRET\"\n\n\n\n# Use the specific configure method for this toolset type\n\ncalendar_tool_set.configure_auth(\n\n    client_id=oauth_client_id, client_secret=oauth_client_secret\n\n)\n\n\n\n# agent = LlmAgent(..., tools=calendar_tool_set.get_tool('calendar_tool_set'))\n\n\nThe sequence diagram of auth request flow (where tools are requesting auth credentials) looks like below:\n\n2. Handling the Interactive OAuth/OIDC Flow (Client-Side)¶\n\nIf a tool requires user login/consent (typically OAuth 2.0 or OIDC), the ADK framework pauses execution and signals your Agent Client application. There are two cases:\n\nAgent Client application runs the agent directly (via runner.run_async) in the same process. e.g. UI backend, CLI app, or Spark job etc.\nAgent Client application interacts with ADK's fastapi server via /run or /run_sse endpoint. While ADK's fastapi server could be setup on the same server or different server as Agent Client application\n\nThe second case is a special case of first case, because /run or /run_sse endpoint also invokes runner.run_async. The only differences are:\n\nWhether to call a python function to run the agent (first case) or call a service endpoint to run the agent (second case).\nWhether the result events are in-memory objects (first case) or serialized json string in http response (second case).\n\nBelow sections focus on the first case and you should be able to map it to the second case very straightforward. We will also describe some differences to handle for the second case if necessary.\n\nHere's the step-by-step process for your client application:\n\nStep 1: Run Agent & Detect Auth Request\n\nInitiate the agent interaction using runner.run_async.\nIterate through the yielded events.\nLook for a specific function call event whose function call has a special name: adk_request_credential. This event signals that user interaction is needed. You can use helper functions to identify this event and extract necessary information. (For the second case, the logic is similar. You deserialize the event from the http response).\n# runner = Runner(...)\n\n# session = session_service.create_session(...)\n\n# content = types.Content(...) # User's initial query\n\n\n\nprint(\"\\nRunning agent...\")\n\nevents_async = runner.run_async(\n\n    session_id=session.id, user_id='user', new_message=content\n\n)\n\n\n\nauth_request_function_call_id, auth_config = None, None\n\n\n\nasync for event in events_async:\n\n    # Use helper to check for the specific auth request event\n\n    if (auth_request_function_call := get_auth_request_function_call(event)):\n\n        print(\"--> Authentication required by agent.\")\n\n        # Store the ID needed to respond later\n\n        if not (auth_request_function_call_id := auth_request_function_call.id):\n\n            raise ValueError(f'Cannot get function call id from function call: {auth_request_function_call}')\n\n        # Get the AuthConfig containing the auth_uri etc.\n\n        auth_config = get_auth_config(auth_request_function_call)\n\n        break # Stop processing events for now, need user interaction\n\n\n\nif not auth_request_function_call_id:\n\n    print(\"\\nAuth not required or agent finished.\")\n\n    # return # Or handle final response if received\n\n\nHelper functions helpers.py:\n\nfrom google.adk.events import Event\n\nfrom google.adk.auth import AuthConfig # Import necessary type\n\nfrom google.genai import types\n\n\n\ndef get_auth_request_function_call(event: Event) -> types.FunctionCall:\n\n    # Get the special auth request function call from the event\n\n    if not event.content or event.content.parts:\n\n        return\n\n    for part in event.content.parts:\n\n        if (\n\n            part \n\n            and part.function_call \n\n            and part.function_call.name == 'adk_request_credential'\n\n            and event.long_running_tool_ids \n\n            and part.function_call.id in event.long_running_tool_ids\n\n        ):\n\n\n\n            return part.function_call\n\n\n\ndef get_auth_config(auth_request_function_call: types.FunctionCall) -> AuthConfig:\n\n    # Extracts the AuthConfig object from the arguments of the auth request function call\n\n    if not auth_request_function_call.args or not (auth_config := auth_request_function_call.args.get('auth_config')):\n\n        raise ValueError(f'Cannot get auth config from function call: {auth_request_function_call}')\n\n    if not isinstance(auth_config, AuthConfig):\n\n        raise ValueError(f'Cannot get auth config {auth_config} is not an instance of AuthConfig.')\n\n    return auth_config\n\n\nStep 2: Redirect User for Authorization\n\nGet the authorization URL (auth_uri) from the auth_config extracted in the previous step.\nCrucially, append your application's redirect_uri as a query parameter to this auth_uri. This redirect_uri must be pre-registered with your OAuth provider (e.g., Google Cloud Console, Okta admin panel).\nDirect the user to this complete URL (e.g., open it in their browser).\n# (Continuing after detecting auth needed)\n\n\n\nif auth_request_function_call_id and auth_config:\n\n    # Get the base authorization URL from the AuthConfig\n\n    base_auth_uri = auth_config.exchanged_auth_credential.oauth2.auth_uri\n\n\n\n    if base_auth_uri:\n\n        redirect_uri = 'http://localhost:8000/callback' # MUST match your OAuth client app config\n\n        # Append redirect_uri (use urlencode in production)\n\n        auth_request_uri = base_auth_uri + f'&redirect_uri={redirect_uri}'\n\n        # Now you need to redirect your end user to this auth_request_uri or ask them to open this auth_request_uri in their browser\n\n        # This auth_request_uri should be served by the corresponding auth provider and the end user should login and authorize your applicaiton to access their data\n\n        # And then the auth provider will redirect the end user to the redirect_uri you provided\n\n        # Next step: Get this callback URL from the user (or your web server handler)\n\n    else:\n\n         print(\"ERROR: Auth URI not found in auth_config.\")\n\n         # Handle error\n\n\nStep 3. Handle the Redirect Callback (Client):\n\nYour application must have a mechanism (e.g., a web server route at the redirect_uri) to receive the user after they authorize the application with the provider.\nThe provider redirects the user to your redirect_uri and appends an authorization_code (and potentially state, scope) as query parameters to the URL.\nCapture the full callback URL from this incoming request.\n(This step happens outside the main agent execution loop, in your web server or equivalent callback handler.)\n\nStep 4. Send Authentication Result Back to ADK (Client):\n\nOnce you have the full callback URL (containing the authorization code), retrieve the auth_request_function_call_id and the auth_config object saved in Client Step 1.\nSet the captured callback URL into the exchanged_auth_credential.oauth2.auth_response_uri field. Also ensure exchanged_auth_credential.oauth2.redirect_uri contains the redirect URI you used.\nCreate a types.Content object containing a types.Part with a types.FunctionResponse.\nSet name to \"adk_request_credential\". (Note: This is a special name for ADK to proceed with authentication. Do not use other names.)\nSet id to the auth_request_function_call_id you saved.\nSet response to the serialized (e.g., .model_dump()) updated AuthConfig object.\nCall runner.run_async again for the same session, passing this FunctionResponse content as the new_message.\n# (Continuing after user interaction)\n\n\n\n    # Simulate getting the callback URL (e.g., from user paste or web handler)\n\n    auth_response_uri = await get_user_input(\n\n        f'Paste the full callback URL here:\\n> '\n\n    )\n\n    auth_response_uri = auth_response_uri.strip() # Clean input\n\n\n\n    if not auth_response_uri:\n\n        print(\"Callback URL not provided. Aborting.\")\n\n        return\n\n\n\n    # Update the received AuthConfig with the callback details\n\n    auth_config.exchanged_auth_credential.oauth2.auth_response_uri = auth_response_uri\n\n    # Also include the redirect_uri used, as the token exchange might need it\n\n    auth_config.exchanged_auth_credential.oauth2.redirect_uri = redirect_uri\n\n\n\n    # Construct the FunctionResponse Content object\n\n    auth_content = types.Content(\n\n        role='user', # Role can be 'user' when sending a FunctionResponse\n\n        parts=[\n\n            types.Part(\n\n                function_response=types.FunctionResponse(\n\n                    id=auth_request_function_call_id,       # Link to the original request\n\n                    name='adk_request_credential', # Special framework function name\n\n                    response=auth_config.model_dump() # Send back the *updated* AuthConfig\n\n                )\n\n            )\n\n        ],\n\n    )\n\n\n\n    # --- Resume Execution ---\n\n    print(\"\\nSubmitting authentication details back to the agent...\")\n\n    events_async_after_auth = runner.run_async(\n\n        session_id=session.id,\n\n        user_id='user',\n\n        new_message=auth_content, # Send the FunctionResponse back\n\n    )\n\n\n\n    # --- Process Final Agent Output ---\n\n    print(\"\\n--- Agent Response after Authentication ---\")\n\n    async for event in events_async_after_auth:\n\n        # Process events normally, expecting the tool call to succeed now\n\n        print(event) # Print the full event for inspection\n\n\nStep 5: ADK Handles Token Exchange & Tool Retry and gets Tool result\n\nADK receives the FunctionResponse for adk_request_credential.\nIt uses the information in the updated AuthConfig (including the callback URL containing the code) to perform the OAuth token exchange with the provider's token endpoint, obtaining the access token (and possibly refresh token).\nADK internally makes these tokens available by setting them in the session state).\nADK automatically retries the original tool call (the one that initially failed due to missing auth).\nThis time, the tool finds the valid tokens (via tool_context.get_auth_response()) and successfully executes the authenticated API call.\nThe agent receives the actual result from the tool and generates its final response to the user.\n\nThe sequence diagram of auth response flow (where Agent Client send back the auth response and ADK retries tool calling) looks like below:\n\nJourney 2: Building Custom Tools (FunctionTool) Requiring Authentication¶\n\nThis section focuses on implementing the authentication logic inside your custom Python function when creating a new ADK Tool. We will implement a FunctionTool as an example.\n\nPrerequisites¶\n\nYour function signature must include tool_context: ToolContext. ADK automatically injects this object, providing access to state and auth mechanisms.\n\nfrom google.adk.tools import FunctionTool, ToolContext\n\nfrom typing import Dict\n\n\n\ndef my_authenticated_tool_function(param1: str, ..., tool_context: ToolContext) -> dict:\n\n    # ... your logic ...\n\n    pass\n\n\n\nmy_tool = FunctionTool(func=my_authenticated_tool_function)\n\nAuthentication Logic within the Tool Function¶\n\nImplement the following steps inside your function:\n\nStep 1: Check for Cached & Valid Credentials:\n\nInside your tool function, first check if valid credentials (e.g., access/refresh tokens) are already stored from a previous run in this session. Credentials for the current sessions should be stored in tool_context.invocation_context.session.state (a dictionary of state) Check existence of existing credentials by checking tool_context.invocation_context.session.state.get(credential_name, None).\n\n# Inside your tool function\n\nTOKEN_CACHE_KEY = \"my_tool_tokens\" # Choose a unique key\n\nSCOPES = [\"scope1\", \"scope2\"] # Define required scopes\n\n\n\ncreds = None\n\ncached_token_info = tool_context.state.get(TOKEN_CACHE_KEY)\n\nif cached_token_info:\n\n    try:\n\n        creds = Credentials.from_authorized_user_info(cached_token_info, SCOPES)\n\n        if not creds.valid and creds.expired and creds.refresh_token:\n\n            creds.refresh(Request())\n\n            tool_context.state[TOKEN_CACHE_KEY] = json.loads(creds.to_json()) # Update cache\n\n        elif not creds.valid:\n\n            creds = None # Invalid, needs re-auth\n\n            tool_context.state[TOKEN_CACHE_KEY] = None\n\n    except Exception as e:\n\n        print(f\"Error loading/refreshing cached creds: {e}\")\n\n        creds = None\n\n        tool_context.state[TOKEN_CACHE_KEY] = None\n\n\n\nif creds and creds.valid:\n\n    # Skip to Step 5: Make Authenticated API Call\n\n    pass\n\nelse:\n\n    # Proceed to Step 2...\n\n    pass\n\n\nStep 2: Check for Auth Response from Client\n\nIf Step 1 didn't yield valid credentials, check if the client just completed the interactive flow by calling exchanged_credential = tool_context.get_auth_response().\nThis returns the updated exchanged_credential object sent back by the client (containing the callback URL in auth_response_uri).\n# Use auth_scheme and auth_credential configured in the tool.\n\n# exchanged_credential: AuthCredential | None\n\n\n\nexchanged_credential = tool_context.get_auth_response(AuthConfig(\n\n  auth_scheme=auth_scheme,\n\n  raw_auth_credential=auth_credential,\n\n))\n\n# If exchanged_credential is not None, then there is already an exchanged credetial from the auth response. \n\nif exchanged_credential:\n\n   # ADK exchanged the access token already for us\n\n        access_token = auth_response.oauth2.access_token\n\n        refresh_token = auth_response.oauth2.refresh_token\n\n        creds = Credentials(\n\n            token=access_token,\n\n            refresh_token=refresh_token,\n\n            token_uri=auth_scheme.flows.authorizationCode.tokenUrl,\n\n            client_id=oauth_client_id,\n\n            client_secret=oauth_client_secret,\n\n            scopes=list(auth_scheme.flows.authorizationCode.scopes.keys()),\n\n        )\n\n    # Cache the token in session state and call the API, skip to step 5\n\n\nStep 3: Initiate Authentication Request\n\nIf no valid credentials (Step 1.) and no auth response (Step 2.) are found, the tool needs to start the OAuth flow. Define the AuthScheme and initial AuthCredential and call tool_context.request_credential(). Return a response indicating authorization is needed.\n\n# Use auth_scheme and auth_credential configured in the tool.\n\n\n\n  tool_context.request_credential(AuthConfig(\n\n    auth_scheme=auth_scheme,\n\n    raw_auth_credential=auth_credential,\n\n  ))\n\n  return {'pending': true, 'message': 'Awaiting user authentication.'}\n\n\n\n# By setting request_credential, ADK detects a pending authentication event. It pauses execution and ask end user to login.\n\n\nStep 4: Exchange Authorization Code for Tokens\n\nADK automatically generates oauth authorization URL and presents it to your Agent Client application. your Agent Client application should follow the same way described in Journey 1 to redirect the user to the authorization URL (with redirect_uri appended). Once a user completes the login flow following the authorization URL and ADK extracts the authentication callback url from Agent Client applications, automatically parses the auth code, and generates auth token. At the next Tool call, tool_context.get_auth_response in step 2 will contain a valid credential to use in subsequent API calls.\n\nStep 5: Cache Obtained Credentials\n\nAfter successfully obtaining the token from ADK (Step 2) or if the token is still valid (Step 1), immediately store the new Credentials object in tool_context.state (serialized, e.g., as JSON) using your cache key.\n\n# Inside your tool function, after obtaining 'creds' (either refreshed or newly exchanged)\n\n# Cache the new/refreshed tokens\n\ntool_context.state[TOKEN_CACHE_KEY] = json.loads(creds.to_json())\n\nprint(f\"DEBUG: Cached/updated tokens under key: {TOKEN_CACHE_KEY}\")\n\n# Proceed to Step 6 (Make API Call)\n\n\nStep 6: Make Authenticated API Call\n\nOnce you have a valid Credentials object (creds from Step 1 or Step 4), use it to make the actual call to the protected API using the appropriate client library (e.g., googleapiclient, requests). Pass the credentials=creds argument.\nInclude error handling, especially for HttpError 401/403, which might mean the token expired or was revoked between calls. If you get such an error, consider clearing the cached token (tool_context.state.pop(...)) and potentially returning the auth_required status again to force re-authentication.\n# Inside your tool function, using the valid 'creds' object\n\n# Ensure creds is valid before proceeding\n\nif not creds or not creds.valid:\n\n   return {\"status\": \"error\", \"error_message\": \"Cannot proceed without valid credentials.\"}\n\n\n\ntry:\n\n   service = build(\"calendar\", \"v3\", credentials=creds) # Example\n\n   api_result = service.events().list(...).execute()\n\n   # Proceed to Step 7\n\nexcept Exception as e:\n\n   # Handle API errors (e.g., check for 401/403, maybe clear cache and re-request auth)\n\n   print(f\"ERROR: API call failed: {e}\")\n\n   return {\"status\": \"error\", \"error_message\": f\"API call failed: {e}\"}\n\n\nStep 7: Return Tool Result\n\nAfter a successful API call, process the result into a dictionary format that is useful for the LLM.\nCrucially, include a along with the data.\n# Inside your tool function, after successful API call\n\n    processed_result = [...] # Process api_result for the LLM\n\n    return {\"status\": \"success\", \"data\": processed_result}\n\nFull Code\n Back to top\nPrevious\nOpenAPI tools\nNext\nAgent Runtime\nCopyright Google 2025\nMade with Material for MkDocs",
  "updatedAt": "2025-05-05T12:53:59.938Z"
}